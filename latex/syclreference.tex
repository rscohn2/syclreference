%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}




\title{SYCL Reference}
\date{May 01, 2020}
\release{}
\author{Intel}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Language}
\label{\detokenize{language/index:language}}\label{\detokenize{language/index::doc}}
SYCL programs are C++ programs. No extensions are added to the language.

\begin{sphinxadmonition}{note}{\label{\detokenize{language/index:id1}}Todo:}
C++ version mininum
\end{sphinxadmonition}


\section{Keywords}
\label{\detokenize{language/index:keywords}}
SYCL does not add any keywords to the C++ language.


\section{Preprocessor Directives and Macros}
\label{\detokenize{language/index:preprocessor-directives-and-macros}}
Standard C++ preprocessing directives and macros are supported by the
compiler. In addition, the SYCL Specification defines the SYCL specific
preprocessor directives and macros.

The following preprocessor macros are supported by the compiler.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Macro
&\sphinxstyletheadfamily 
Value
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{SYCL\_DUMP\_IMAGES}}
&
\sphinxcode{\sphinxupquote{true}} or \sphinxcode{\sphinxupquote{false}}
&
Instructs the runtime to dump the device image
\\
\hline
\sphinxcode{\sphinxupquote{SYCL\_USE\_KERNEL\_SPV}}
&
\textless{}device binary\textgreater{}
&
Employ device binary to fulfill kernel launch request
\\
\hline
\sphinxcode{\sphinxupquote{SYCL\_PROGRAM\_BUILD\_OPTIONS}}
&
\textless{}options\textgreater{}
&
Used to pass additional options for device program building.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Standard Library Classes Required for the Interface}
\label{\detokenize{language/index:standard-library-classes-required-for-the-interface}}
The SYCL specification documents a facility to enable vendors to provide
custom optimized implementations. Implementations require aliases for
several STL interfaces. These are summarized as follows:

\begin{sphinxadmonition}{note}{\label{\detokenize{language/index:id2}}Todo:}
add STL interfaces
\end{sphinxadmonition}


\chapter{Programming Interface}
\label{\detokenize{programming-interface/index:programming-interface}}\label{\detokenize{programming-interface/index::doc}}
For further details on SYCL, see the \sphinxhref{https://www.khronos.org/registry/SYCL/specs/sycl-1.2.1.pdf}{SYCL
Specification}.


\section{Header File}
\label{\detokenize{programming-interface/index:header-file}}
A single header file must be included:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}sycl.hpp\PYGZdq{}}
\end{sphinxVerbatim}


\section{Namespaces}
\label{\detokenize{programming-interface/index:namespaces}}
Unless otherwise noted, all symbols should be prefixed with the
\sphinxcode{\sphinxupquote{cl::sycl}} namespace. \sphinxcode{\sphinxupquote{buffer}} is \sphinxcode{\sphinxupquote{cl::sycl::buffer}}, and
\sphinxcode{\sphinxupquote{info::device::name}} is \sphinxcode{\sphinxupquote{cl::sycl::info::device::name}}.


\section{Standard Library Classes}
\label{\detokenize{programming-interface/index:standard-library-classes}}

\section{Runtime classes}
\label{\detokenize{programming-interface/index:runtime-classes}}

\subsection{Device Selectors}
\label{\detokenize{programming-interface/runtime/device-selectors:device-selectors}}\label{\detokenize{programming-interface/runtime/device-selectors::doc}}
Devices selectors allow the SYCL runtime to choose the
device. Built\sphinxhyphen{}in device selectors allow the user to restrict the type
of device. Users can also specify their own heuristics for choosing
the device by implementing their own \sphinxcode{\sphinxupquote{device\_selector}}.


\subsubsection{Device selection class}
\label{\detokenize{programming-interface/runtime/device-selector:device-selection-class}}\label{\detokenize{programming-interface/runtime/device-selector::doc}}

\paragraph{Device selector interface}
\label{\detokenize{programming-interface/runtime/device-selector:device-selector-interface}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{device\PYGZus{}selector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{device\_selector}} is an abstract class that cann
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/device-selector:constructor}]{\sphinxcrossref{(constructor)}}}
&
constructs a device\_selector
\\
\hline
(destructor)
&
destroys the device\_selector
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device-selector:select-device}]{\sphinxcrossref{select\_device}}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Nonmember functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

operator()
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subparagraph{(constructor)}
\label{\detokenize{programming-interface/runtime/device-selector:constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{device\PYGZus{}selector}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{rhs}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{rhs}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Constructs a \sphinxcode{\sphinxupquote{device\_selector}} from another \sphinxcode{\sphinxupquote{device\_selector}}
\subsubsection*{Parameters}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{rhs}} \sphinxhyphen{} device
\end{DUlineblock}


\subparagraph{select\_device}
\label{\detokenize{programming-interface/runtime/device-selector:select-device}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{device} \PYG{n}{select\PYGZus{}device}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subparagraph{operator()}
\label{\detokenize{programming-interface/runtime/device-selector:operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{virtual} \PYG{n+nb}{int} \PYG{n}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{device}\PYG{p}{)} \PYG{n}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\paragraph{Derived device selector}
\label{\detokenize{programming-interface/runtime/device-selector:derived-device-selector}}

\subparagraph{default\_selector}
\label{\detokenize{programming-interface/runtime/device-selector:default-selector}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{default\PYGZus{}selector}\PYG{p}{;}
\end{sphinxVerbatim}

Selects a SYCL device based on a implementation\sphinxhyphen{}defined
heuristic. Selects a {\hyperref[\detokenize{glossary:term-host-device}]{\sphinxtermref{\DUrole{xref,std,std-term}{host device}}}} if no other device can be
found.


\subparagraph{gpu\_selector}
\label{\detokenize{programming-interface/runtime/device-selector:gpu-selector}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{gpu\PYGZus{}selector}\PYG{p}{;}
\end{sphinxVerbatim}

Selects a GPU.
\subsubsection*{Exceptions}

Throws a \sphinxcode{\sphinxupquote{runtime\_error}} if a GPU device cannot be found

\phantomsection\label{\detokenize{programming-interface/runtime/device-selector:gpu-selector-example}}\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}CL/sycl.hpp\PYGZgt{}}

\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{cl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{sycl}\PYG{p}{;}

\PYG{n+nb}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{device} \PYG{n}{d}\PYG{p}{;}
  
  \PYG{k}{try} \PYG{p}{\PYGZob{}}
    \PYG{n}{d} \PYG{o}{=} \PYG{n}{device}\PYG{p}{(}\PYG{n}{gpu\PYGZus{}selector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}} \PYG{n}{catch} \PYG{p}{(}\PYG{n}{exception} \PYG{n}{const}\PYG{o}{\PYGZam{}} \PYG{n}{e}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cannot select a GPU}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{e}\PYG{o}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Using a CPU device}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{d} \PYG{o}{=} \PYG{n}{device}\PYG{p}{(}\PYG{n}{cpu\PYGZus{}selector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Using }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{d}\PYG{o}{.}\PYG{n}{get\PYGZus{}info}\PYG{o}{\PYGZlt{}}\PYG{n}{sycl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device}\PYG{p}{:}\PYG{p}{:}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Output on a system without a GPU


\subparagraph{accelerator\_selector}
\label{\detokenize{programming-interface/runtime/device-selector:accelerator-selector}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{accelerator\PYGZus{}selector}\PYG{p}{;}
\end{sphinxVerbatim}

Selects an accelerator.
\subsubsection*{Exceptions}

Throws a \sphinxcode{\sphinxupquote{runtime\_error}} if an accelerator device cannot be found.
\subsubsection*{Example}

See {\hyperref[\detokenize{programming-interface/runtime/device-selector:gpu-selector-example}]{\sphinxcrossref{\DUrole{std,std-ref}{Example}}}} for the use of a pre\sphinxhyphen{}defined selector.


\subparagraph{cpu\_selector}
\label{\detokenize{programming-interface/runtime/device-selector:cpu-selector}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{cpu\PYGZus{}selector}\PYG{p}{;}
\end{sphinxVerbatim}

Select a CPU device.
\subsubsection*{Exceptions}

Throws a \sphinxcode{\sphinxupquote{runtime\_error}} if a CPU device cannot be found.
\subsubsection*{Example}

See {\hyperref[\detokenize{programming-interface/runtime/device-selector:gpu-selector-example}]{\sphinxcrossref{\DUrole{std,std-ref}{Example}}}} for the use of a pre\sphinxhyphen{}defined selector.


\subparagraph{host\_selector}
\label{\detokenize{programming-interface/runtime/device-selector:host-selector}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{host\PYGZus{}selector}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Example}

See {\hyperref[\detokenize{programming-interface/runtime/device-selector:gpu-selector-example}]{\sphinxcrossref{\DUrole{std,std-ref}{Example}}}} for the use of a pre\sphinxhyphen{}defined selector.


\subsection{Platform class}
\label{\detokenize{programming-interface/runtime/platform:platform-class}}\label{\detokenize{programming-interface/runtime/platform::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{platform}\PYG{p}{;}
\end{sphinxVerbatim}

Abstraction for SYCL platform.
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/platform:constructor}]{\sphinxcrossref{(constructor)}}}
&
constructs a platform
\\
\hline
destructor
&
destroys a platform
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/platform:get}]{\sphinxcrossref{get}}}
&
returns OpenCL platform ID
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/platform:get-devices}]{\sphinxcrossref{get\_devices}}}
&
returns devices bound to the platform
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/platform:get-info}]{\sphinxcrossref{get\_info}}}
&
queries properties of the platform
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/platform:has-extension}]{\sphinxcrossref{has\_extension}}}
&
checks if platform has an extension
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/platform:is-host}]{\sphinxcrossref{is\_host}}}
&
checks if platform has a SYCL host device
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Nonmember functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/platform:get-platforms}]{\sphinxcrossref{get\_platforms}}}
&
returns available platforms
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\phantomsection\label{\detokenize{programming-interface/runtime/platform:platform-example}}\subsubsection*{Example}

Enumerate the platforms and the devices they contain.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}CL/sycl.hpp\PYGZgt{}}

\PYG{n}{namespace} \PYG{n}{sycl} \PYG{o}{=} \PYG{n}{cl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{sycl}\PYG{p}{;}

\PYG{n+nb}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{auto} \PYG{n}{platforms} \PYG{o}{=} \PYG{n}{sycl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{platform}\PYG{p}{:}\PYG{p}{:}\PYG{n}{get\PYGZus{}platforms}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{o}{\PYGZam{}}\PYG{n}{platform} \PYG{p}{:} \PYG{n}{platforms}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Platform: }\PYG{l+s+s2}{\PYGZdq{}}
	      \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{platform}\PYG{o}{.}\PYG{n}{get\PYGZus{}info}\PYG{o}{\PYGZlt{}}\PYG{n}{sycl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{platform}\PYG{p}{:}\PYG{p}{:}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
	      \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}

    \PYG{n}{auto} \PYG{n}{devices} \PYG{o}{=} \PYG{n}{platform}\PYG{o}{.}\PYG{n}{get\PYGZus{}devices}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{o}{\PYGZam{}}\PYG{n}{device} \PYG{p}{:} \PYG{n}{devices} \PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  Device: }\PYG{l+s+s2}{\PYGZdq{}}
		\PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{device}\PYG{o}{.}\PYG{n}{get\PYGZus{}info}\PYG{o}{\PYGZlt{}}\PYG{n}{sycl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device}\PYG{p}{:}\PYG{p}{:}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
		\PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Platform}\PYG{p}{:} \PYG{n}{Intel}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{n}{FPGA} \PYG{n}{Emulation} \PYG{n}{Platform} \PYG{k}{for} \PYG{n}{OpenCL}\PYG{p}{(}\PYG{n}{TM}\PYG{p}{)}
  \PYG{n}{Device}\PYG{p}{:} \PYG{n}{Intel}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{n}{FPGA} \PYG{n}{Emulation} \PYG{n}{Device}
\PYG{n}{Platform}\PYG{p}{:} \PYG{n}{Intel}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{n}{OpenCL}
  \PYG{n}{Device}\PYG{p}{:} \PYG{n}{Intel}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{n}{Core}\PYG{p}{(}\PYG{n}{TM}\PYG{p}{)} \PYG{n}{i5}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7300}\PYG{n}{U} \PYG{n}{CPU} \PYG{o}{@} \PYG{l+m+mf}{2.60}\PYG{n}{GHz}
\PYG{n}{Platform}\PYG{p}{:} \PYG{n}{Intel}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{n}{CPU} \PYG{n}{Runtime} \PYG{k}{for} \PYG{n}{OpenCL}\PYG{p}{(}\PYG{n}{TM}\PYG{p}{)} \PYG{n}{Applications}
  \PYG{n}{Device}\PYG{p}{:} \PYG{n}{Intel}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{n}{Core}\PYG{p}{(}\PYG{n}{TM}\PYG{p}{)} \PYG{n}{i5}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7300}\PYG{n}{U} \PYG{n}{CPU} \PYG{o}{@} \PYG{l+m+mf}{2.60}\PYG{n}{GHz}
\PYG{n}{Platform}\PYG{p}{:} \PYG{n}{SYCL} \PYG{n}{host} \PYG{n}{platform}
  \PYG{n}{Device}\PYG{p}{:} \PYG{n}{SYCL} \PYG{n}{host} \PYG{n}{device}
\end{sphinxVerbatim}


\subsubsection{(constructor)}
\label{\detokenize{programming-interface/runtime/platform:constructor}}\label{\detokenize{programming-interface/runtime/platform:platform-constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{platform}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{sphinxalltt}
explicit platform(cl\_platform\_id platformID);             \begin{footnote}[1]\sphinxAtStartFootnote
Constructs a SYCL platform that retains an OpenCL id
\end{footnote}
\end{sphinxalltt}
\begin{sphinxalltt}
explicit platform(const device\_selector \&deviceSelector); \begin{footnote}[2]\sphinxAtStartFootnote
Selects a platform that contains the desired device
\end{footnote}
\end{sphinxalltt}

Constructs a platform handle.
\subsubsection*{Parameters}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{platformID}} \sphinxhyphen{} OpenCL platform ID
\item[] \sphinxcode{\sphinxupquote{deviceSelector}} \sphinxhyphen{}  Platform must contain the selected device
\end{DUlineblock}


\subsubsection{get}
\label{\detokenize{programming-interface/runtime/platform:get}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cl\PYGZus{}platform\PYGZus{}id} \PYG{n}{get}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Returns OpenCL platform id used in the constructor.


\subsubsection{get\_devices}
\label{\detokenize{programming-interface/runtime/platform:get-devices}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{device}\PYG{o}{\PYGZgt{}} \PYG{n}{get\PYGZus{}devices}\PYG{p}{(}
   \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device\PYGZus{}type} \PYG{o}{=} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device\PYGZus{}type}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{all}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Returns vector of devices of the requested type
\subsubsection*{Parameters}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{device\_type}} \sphinxhyphen{} limits type of device returned
\end{DUlineblock}
\subsubsection*{Returns}

\sphinxcode{\sphinxupquote{vector}} containing devices of the specified type bound to the
platform.
\subsubsection*{Example}

See {\hyperref[\detokenize{programming-interface/runtime/platform:platform-example}]{\sphinxcrossref{platform\sphinxhyphen{}example}}}.


\subsubsection{get\_info}
\label{\detokenize{programming-interface/runtime/platform:get-info}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template}\PYG{o}{\PYGZlt{}} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{platform} \PYG{n}{param} \PYG{o}{\PYGZgt{}}
\PYG{n}{typename} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{param\PYGZus{}traits}\PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{platform}\PYG{p}{,} \PYG{n}{param}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{return\PYGZus{}type} \PYG{n}{get\PYGZus{}info}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Returns information about the platform, as specified by \sphinxcode{\sphinxupquote{param}}.
\subsubsection*{Returns}

Requested information
\subsubsection*{Example}

See {\hyperref[\detokenize{programming-interface/runtime/platform:platform-example}]{\sphinxcrossref{platform\sphinxhyphen{}example}}}.


\subsubsection{has\_extension}
\label{\detokenize{programming-interface/runtime/platform:has-extension}}\label{\detokenize{programming-interface/runtime/platform:platform-has-extension}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{has\PYGZus{}extension}\PYG{p}{(}\PYG{n}{const} \PYG{n}{string\PYGZus{}class} \PYG{o}{\PYGZam{}}\PYG{n}{extension}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Checks if the platform has the requested extension.
\subsubsection*{Parameters}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{extension}} \sphinxhyphen{}
\end{DUlineblock}
\subsubsection*{Returns}

\sphinxcode{\sphinxupquote{true}} if the platform has \sphinxcode{\sphinxupquote{extension}}


\subsubsection{is\_host}
\label{\detokenize{programming-interface/runtime/platform:is-host}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}host}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Checks if the platform contains a SYCL {\hyperref[\detokenize{glossary:term-host-device}]{\sphinxtermref{\DUrole{xref,std,std-term}{host device}}}}
\subsubsection*{Returns}

\sphinxcode{\sphinxupquote{true}} if the platform contains a host device


\subsubsection{get\_platforms}
\label{\detokenize{programming-interface/runtime/platform:get-platforms}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{static} \PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{platform}\PYG{o}{\PYGZgt{}} \PYG{n}{get\PYGZus{}platforms}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Returns vector of platforms
\subsubsection*{Returns}

vector\_class containing SYCL platforms bound to the system
\subsubsection*{Example}

See {\hyperref[\detokenize{programming-interface/runtime/platform:platform-example}]{\sphinxcrossref{platform\sphinxhyphen{}example}}}.


\subsection{Context class}
\label{\detokenize{programming-interface/runtime/context:context-class}}\label{\detokenize{programming-interface/runtime/context::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{context}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/context:constructor}]{\sphinxcrossref{(constructor)}}}
&
constructs a context
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/context:get}]{\sphinxcrossref{get}}}
&
returns OpenCL conext ID
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/context:is-host}]{\sphinxcrossref{is\_host}}}
&
checks if contains a SYCL host device
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/context:get-platform}]{\sphinxcrossref{get\_platform}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/context:get-devices}]{\sphinxcrossref{get\_devices}}}
&
returns devices bound to the context
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/context:get-info}]{\sphinxcrossref{get\_info}}}
&
queries properties
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{(constructor)}
\label{\detokenize{programming-interface/runtime/context:constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{context}\PYG{p}{(}\PYG{n}{async\PYGZus{}handler} \PYG{n}{asyncHandler}\PYG{p}{,}
        \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{dev}\PYG{p}{,} \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{dev}\PYG{p}{,} \PYG{n}{async\PYGZus{}handler} \PYG{n}{asyncHandler}\PYG{p}{,}
        \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{platform} \PYG{o}{\PYGZam{}}\PYG{n}{plt}\PYG{p}{,} \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{platform} \PYG{o}{\PYGZam{}}\PYG{n}{plt}\PYG{p}{,} \PYG{n}{async\PYGZus{}handler} \PYG{n}{asyncHandler}\PYG{p}{,}
        \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{device}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{deviceList}\PYG{p}{,}
        \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{device}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{deviceList}\PYG{p}{,}
        \PYG{n}{async\PYGZus{}handler} \PYG{n}{asyncHandler}\PYG{p}{,} \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{context}\PYG{p}{(}\PYG{n}{cl\PYGZus{}context} \PYG{n}{clContext}\PYG{p}{,} \PYG{n}{async\PYGZus{}handler} \PYG{n}{asyncHandler} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Parameters}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{propList}} \sphinxhyphen{}
\item[] \sphinxcode{\sphinxupquote{asyncHandler}} \sphinxhyphen{}
\item[] \sphinxcode{\sphinxupquote{dev}} \sphinxhyphen{}
\item[] \sphinxcode{\sphinxupquote{plt}} \sphinxhyphen{}
\item[] \sphinxcode{\sphinxupquote{deviceList}} \sphinxhyphen{}
\end{DUlineblock}


\subsubsection{get}
\label{\detokenize{programming-interface/runtime/context:get}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cl\PYGZus{}context} \PYG{n}{get}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{is\_host}
\label{\detokenize{programming-interface/runtime/context:is-host}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}host}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{get\_platform}
\label{\detokenize{programming-interface/runtime/context:get-platform}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{platform} \PYG{n}{get\PYGZus{}platform}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{get\_devices}
\label{\detokenize{programming-interface/runtime/context:get-devices}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{device}\PYG{o}{\PYGZgt{}} \PYG{n}{get\PYGZus{}devices}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{get\_info}
\label{\detokenize{programming-interface/runtime/context:get-info}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{context} \PYG{n}{param}\PYG{o}{\PYGZgt{}}
\PYG{n}{typename} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{param\PYGZus{}traits}\PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{context}\PYG{p}{,} \PYG{n}{param}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{return\PYGZus{}type} \PYG{n}{get\PYGZus{}info}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsection{Device class}
\label{\detokenize{programming-interface/runtime/device:device-class}}\label{\detokenize{programming-interface/runtime/device::doc}}

\subsubsection{Device interface}
\label{\detokenize{programming-interface/runtime/device:device-interface}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{device}\PYG{p}{;}
\end{sphinxVerbatim}

An abstract class representing various models of SYCL devices
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/device:constructor}]{\sphinxcrossref{(constructor)}}}
&\\
\hline
(destructor)
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:get}]{\sphinxcrossref{get}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:is-host}]{\sphinxcrossref{is\_host}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:is-cpu}]{\sphinxcrossref{is\_cpu}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:is-gpu}]{\sphinxcrossref{is\_gpu}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:is-accelerator}]{\sphinxcrossref{is\_accelerator}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:get-platform}]{\sphinxcrossref{get\_platform}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:get-info}]{\sphinxcrossref{get\_info}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:has-extension}]{\sphinxcrossref{has\_extension}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:create-sub-devices}]{\sphinxcrossref{create\_sub\_devices}}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Nonmember functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/device:get-devices}]{\sphinxcrossref{get\_devices}}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{(constructor)}
\label{\detokenize{programming-interface/runtime/device:constructor}}\begin{sphinxalltt}
device();                                                \begin{footnote}[4]\sphinxAtStartFootnote
Default Constructor. Constructs a device object in host
mode.
\end{footnote}
\end{sphinxalltt}
\begin{sphinxalltt}
explicit device(cl\_device\_id deviceId);                  \begin{footnote}[5]\sphinxAtStartFootnote
Constructs a device object from another device object and
retains the cl\_device\_id object if the device is not in
host mode.
\end{footnote}
\end{sphinxalltt}
\begin{sphinxalltt}
explicit device(const device\_selector \&deviceSelector);  \begin{footnote}[6]\sphinxAtStartFootnote
Use deviceSelector to choose device
\end{footnote}
\end{sphinxalltt}
\subsubsection*{Parameters}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{deviceID}} \sphinxhyphen{} OpenCL device id
\item[] \sphinxcode{\sphinxupquote{deviceSelector}} \sphinxhyphen{} Device selector
\end{DUlineblock}


\paragraph{get}
\label{\detokenize{programming-interface/runtime/device:get}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cl\PYGZus{}device\PYGZus{}id} \PYG{n}{get}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Return the cl\_device\_id of the underlying OpenCL platform
\subsubsection*{Returns}

cl\_device\_id of underlying OpenCL platform


\paragraph{is\_host}
\label{\detokenize{programming-interface/runtime/device:is-host}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}host}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Checks if the device is a SYCL host device
\subsubsection*{Returns}

True if the device is a {\hyperref[\detokenize{glossary:term-host-device}]{\sphinxtermref{\DUrole{xref,std,std-term}{host device}}}}, false otherwise.


\paragraph{is\_cpu}
\label{\detokenize{programming-interface/runtime/device:is-cpu}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}cpu}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Checks if the device is a CPU
\subsubsection*{Returns}

True if the device is a CPU, false otherwise


\paragraph{is\_gpu}
\label{\detokenize{programming-interface/runtime/device:is-gpu}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}gpu}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Checks if the device is a GPU
\subsubsection*{Returns}

True if the device is a GPU, false otherwise


\paragraph{is\_accelerator}
\label{\detokenize{programming-interface/runtime/device:is-accelerator}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}accelerator}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Checks if the device is a GPU
\subsubsection*{Returns}

True if the device is a GPU, false otherwise


\paragraph{get\_platform}
\label{\detokenize{programming-interface/runtime/device:get-platform}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{platform} \PYG{n}{get\PYGZus{}platform}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Returns the platform that contains the device
\subsubsection*{Returns}

Platform object


\paragraph{get\_info}
\label{\detokenize{programming-interface/runtime/device:get-info}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device} \PYG{n}{param}\PYG{o}{\PYGZgt{}}
\PYG{n}{typename} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{param\PYGZus{}traits}\PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device}\PYG{p}{,} \PYG{n}{param}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{return\PYGZus{}type}
\PYG{n}{get\PYGZus{}info}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Queries the device for information specific to \sphinxcode{\sphinxupquote{param}}.
\subsubsection*{Template parameters}

\sphinxcode{\sphinxupquote{param}} \sphinxhyphen{} refer to \sphinxurl{info::device} table
\subsubsection*{Returns}

Device information
\subsubsection*{Example}

See {\hyperref[\detokenize{programming-interface/runtime/platform:platform-example}]{\sphinxcrossref{\DUrole{std,std-ref}{Example}}}}.


\paragraph{has\_extension}
\label{\detokenize{programming-interface/runtime/device:has-extension}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{has\PYGZus{}extension}\PYG{p}{(}\PYG{n}{const} \PYG{n}{string\PYGZus{}class} \PYG{o}{\PYGZam{}}\PYG{n}{extension}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Check
\subsubsection*{Parameters}

\sphinxcode{\sphinxupquote{extension}} \sphinxhyphen{} name of extension
\subsubsection*{Returns}


\paragraph{create\_sub\_devices}
\label{\detokenize{programming-interface/runtime/device:create-sub-devices}}\begin{sphinxalltt}
template \textless{}\sphinxurl{info::partition\_property} prop\textgreater{}
vector\_class\textless{}device\textgreater{} create\_sub\_devices(size\_t nbSubDev) const; \begin{footnote}[7]\sphinxAtStartFootnote
Available only when prop == \sphinxurl{info::partition\_property::partition\_equally}
\end{footnote}
\end{sphinxalltt}
\begin{sphinxalltt}
template \textless{}\sphinxurl{info::partition\_property} prop\textgreater{}
vector\_class\textless{}device\textgreater{} create\_sub\_devices(const vector\_class\textless{}size\_t\textgreater{} \&counts) const; \begin{footnote}[8]\sphinxAtStartFootnote
Available only when prop == \sphinxurl{info::partition\_property::partition\_by\_counts}
\end{footnote}
\end{sphinxalltt}
\begin{sphinxalltt}
template \textless{}\sphinxurl{info::partition\_property} prop\textgreater{}
vector\_class\textless{}device\textgreater{} create\_sub\_devices(\sphinxurl{info::affinity\_domain} affinityDomain) const; \begin{footnote}[9]\sphinxAtStartFootnote
Available only when prop == \sphinxurl{info::partition\_property::partition\_by\_affinity\_domain}
\end{footnote}
\end{sphinxalltt}
\subsubsection*{Parameters}

nbSubDev \sphinxhyphen{}
counts \sphinxhyphen{}
affinityDomain \sphinxhyphen{}
\subsubsection*{Returns}


\paragraph{get\_devices}
\label{\detokenize{programming-interface/runtime/device:get-devices}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{static} \PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{device}\PYG{o}{\PYGZgt{}} \PYG{n}{get\PYGZus{}devices}\PYG{p}{(}
    \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device\PYGZus{}type} \PYG{n}{deviceType} \PYG{o}{=} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device\PYGZus{}type}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{all}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsection{queue}
\label{\detokenize{programming-interface/runtime/queue:queue}}\label{\detokenize{programming-interface/runtime/queue::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{queue}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/queue:constructor}]{\sphinxcrossref{(constructor)}}}
&\\
\hline
(destructor)
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:get}]{\sphinxcrossref{get}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:get-context}]{\sphinxcrossref{get\_context}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:get-device}]{\sphinxcrossref{get\_device}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:get-info}]{\sphinxcrossref{get\_info}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:is-host}]{\sphinxcrossref{is\_host}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:submit}]{\sphinxcrossref{submit}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:wait}]{\sphinxcrossref{wait}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:wait-and-throw}]{\sphinxcrossref{wait\_and\_throw}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:throw-asynchronous}]{\sphinxcrossref{throw\_asynchronous}}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{(constructor)}
\label{\detokenize{programming-interface/runtime/queue:constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{async\PYGZus{}handler} \PYG{o}{\PYGZam{}}\PYG{n}{asyncHandler}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{description}
\item[{::}] \leavevmode\begin{description}
\item[{explicit queue(const device\_selector \&deviceSelector,}] \leavevmode
const property\_list \&propList = \{\});

\end{description}

\end{description}
\begin{description}
\item[{::}] \leavevmode\begin{description}
\item[{explicit queue(const device\_selector \&deviceSelector,}] \leavevmode
const async\_handler \&asyncHandler,
const property\_list \&propList = \{\});

\end{description}

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{syclDevice}\PYG{p}{,} \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{syclDevice}\PYG{p}{,} \PYG{n}{const} \PYG{n}{async\PYGZus{}handler} \PYG{o}{\PYGZam{}}\PYG{n}{asyncHandler}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{context} \PYG{o}{\PYGZam{}}\PYG{n}{syclContext}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{deviceSelector}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{context} \PYG{o}{\PYGZam{}}\PYG{n}{syclContext}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{deviceSelector}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{async\PYGZus{}handler} \PYG{o}{\PYGZam{}}\PYG{n}{asyncHandler}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{context} \PYG{o}{\PYGZam{}}\PYG{n}{syclContext}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{syclDevice}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{context} \PYG{o}{\PYGZam{}}\PYG{n}{syclContext}\PYG{p}{,} \PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{syclDevice}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{async\PYGZus{}handler} \PYG{o}{\PYGZam{}}\PYG{n}{asyncHandler}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{cl\PYGZus{}command\PYGZus{}queue} \PYG{n}{clQueue}\PYG{p}{,} \PYG{n}{const} \PYG{n}{context}\PYG{o}{\PYGZam{}} \PYG{n}{syclContext}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{async\PYGZus{}handler} \PYG{o}{\PYGZam{}}\PYG{n}{asyncHandler} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{get}
\label{\detokenize{programming-interface/runtime/queue:get}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cl\PYGZus{}command\PYGZus{}queue} \PYG{n}{get}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{get\_context}
\label{\detokenize{programming-interface/runtime/queue:get-context}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{context} \PYG{n}{get\PYGZus{}context}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{get\_device}
\label{\detokenize{programming-interface/runtime/queue:get-device}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{device} \PYG{n}{get\PYGZus{}device}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{is\_host}
\label{\detokenize{programming-interface/runtime/queue:is-host}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}host}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{get\_info}
\label{\detokenize{programming-interface/runtime/queue:get-info}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{queue} \PYG{n}{param}\PYG{o}{\PYGZgt{}}
\PYG{n}{typename} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{param\PYGZus{}traits}\PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{queue}\PYG{p}{,} \PYG{n}{param}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{return\PYGZus{}type} \PYG{n}{get\PYGZus{}info}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{submit}
\label{\detokenize{programming-interface/runtime/queue:submit}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{event} \PYG{n}{submit}\PYG{p}{(}\PYG{n}{T} \PYG{n}{cgf}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{event} \PYG{n}{submit}\PYG{p}{(}\PYG{n}{T} \PYG{n}{cgf}\PYG{p}{,} \PYG{n}{const} \PYG{n}{queue} \PYG{o}{\PYGZam{}}\PYG{n}{secondaryQueue}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Parameters}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{cgf}} \sphinxhyphen{}
\item[] \sphinxcode{\sphinxupquote{secondaryQueue}} \sphinxhyphen{}
\end{DUlineblock}
\subsubsection*{Returns}


\subsubsection{wait}
\label{\detokenize{programming-interface/runtime/queue:wait}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{wait}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{wait\_and\_throw}
\label{\detokenize{programming-interface/runtime/queue:wait-and-throw}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{wait\PYGZus{}and\PYGZus{}throw}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{throw\_asynchronous}
\label{\detokenize{programming-interface/runtime/queue:throw-asynchronous}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{throw\PYGZus{}asynchronous}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{event}
\label{\detokenize{programming-interface/runtime/event:event}}\label{\detokenize{programming-interface/runtime/event::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{event}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/event:constructor}]{\sphinxcrossref{(constructor)}}}
&\\
\hline
(destructor)
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:cl-event-get}]{\sphinxcrossref{cl\_event\_get}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:is-host}]{\sphinxcrossref{is\_host}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:get-wait-list}]{\sphinxcrossref{get\_wait\_list}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:wait}]{\sphinxcrossref{wait}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:wait-and-throw}]{\sphinxcrossref{wait\_and\_throw}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:get-info}]{\sphinxcrossref{get\_info}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:get-profiling-info}]{\sphinxcrossref{get\_profiling\_info}}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{(constructor)}
\label{\detokenize{programming-interface/runtime/event:constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{event}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{event}\PYG{p}{(}\PYG{n}{cl\PYGZus{}event} \PYG{n}{clEvent}\PYG{p}{,} \PYG{n}{const} \PYG{n}{context}\PYG{o}{\PYGZam{}} \PYG{n}{syclContext}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{cl\_event\_get}
\label{\detokenize{programming-interface/runtime/event:cl-event-get}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cl\PYGZus{}event} \PYG{n}{get}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{is\_host}
\label{\detokenize{programming-interface/runtime/event:is-host}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}host}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{get\_wait\_list}
\label{\detokenize{programming-interface/runtime/event:get-wait-list}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{event}\PYG{o}{\PYGZgt{}} \PYG{n}{get\PYGZus{}wait\PYGZus{}list}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{wait}
\label{\detokenize{programming-interface/runtime/event:wait}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{wait}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{static} \PYG{n}{void} \PYG{n}{wait}\PYG{p}{(}\PYG{n}{const} \PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{event}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{eventList}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{wait\_and\_throw}
\label{\detokenize{programming-interface/runtime/event:wait-and-throw}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{wait\PYGZus{}and\PYGZus{}throw}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{static} \PYG{n}{void} \PYG{n}{wait\PYGZus{}and\PYGZus{}throw}\PYG{p}{(}\PYG{n}{const} \PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{event}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{eventList}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{get\_info}
\label{\detokenize{programming-interface/runtime/event:get-info}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{event} \PYG{n}{param}\PYG{o}{\PYGZgt{}}
\PYG{n}{typename} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{param\PYGZus{}traits}\PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{event}\PYG{p}{,} \PYG{n}{param}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{return\PYGZus{}type} \PYG{n}{get\PYGZus{}info}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\subsubsection{get\_profiling\_info}
\label{\detokenize{programming-interface/runtime/event:get-profiling-info}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{event\PYGZus{}profiling} \PYG{n}{param}\PYG{o}{\PYGZgt{}}
\PYG{n}{typename} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{param\PYGZus{}traits}\PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{event\PYGZus{}profiling}\PYG{p}{,} \PYG{n}{param}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{return\PYGZus{}type} \PYG{n}{get\PYGZus{}profiling\PYGZus{}info}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Returns}


\section{Data access}
\label{\detokenize{programming-interface/index:data-access}}

\subsection{Buffers}
\label{\detokenize{programming-interface/data/buffer:buffers}}\label{\detokenize{programming-interface/data/buffer::doc}}

\subsubsection{Buffer interface}
\label{\detokenize{programming-interface/data/buffer:buffer-interface}}

\subsubsection{Buffer properties}
\label{\detokenize{programming-interface/data/buffer:buffer-properties}}

\subsection{Images}
\label{\detokenize{programming-interface/data/image:images}}\label{\detokenize{programming-interface/data/image::doc}}

\subsubsection{Image interface}
\label{\detokenize{programming-interface/data/image:image-interface}}

\subsubsection{Image properties}
\label{\detokenize{programming-interface/data/image:image-properties}}

\subsection{Accessors}
\label{\detokenize{programming-interface/data/accessor:accessors}}\label{\detokenize{programming-interface/data/accessor::doc}}

\subsubsection{accessor}
\label{\detokenize{programming-interface/data/accessor:accessor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template}\PYG{o}{\PYGZlt{}}
    \PYG{n}{typename} \PYG{n}{dataT}\PYG{p}{,}
    \PYG{n+nb}{int} \PYG{n}{dimensions}\PYG{p}{,}
    \PYG{n}{access}\PYG{p}{:}\PYG{p}{:}\PYG{n}{mode} \PYG{n}{accessmode}\PYG{p}{,}
    \PYG{n}{access}\PYG{p}{:}\PYG{p}{:}\PYG{n}{target} \PYG{n}{accessTarget} \PYG{o}{=} \PYG{n}{access}\PYG{p}{:}\PYG{p}{:}\PYG{n}{target}\PYG{p}{:}\PYG{p}{:}\PYG{n}{global\PYGZus{}buffer}\PYG{p}{,}
    \PYG{n}{access}\PYG{p}{:}\PYG{p}{:}\PYG{n}{placeholder} \PYG{n}{isPlaceholder} \PYG{o}{=} \PYG{n}{access}\PYG{p}{:}\PYG{p}{:}\PYG{n}{placeholder}\PYG{p}{:}\PYG{p}{:}\PYG{n}{false\PYGZus{}t}
\PYG{o}{\PYGZgt{}} \PYG{k}{class} \PYG{n+nc}{accessor}\PYG{p}{;}
\end{sphinxVerbatim}

A DPC++ \sphinxcode{\sphinxupquote{accessor}} encapsulates reading and writing memory objects
which can be buffers, images, or device local memory. Creating an
accessor requires a method to reference the desired access target.
Construction also requires the type of the memory object, the
dimensionality of the memory object, the access mode, and a placeholder
argument.
\subsubsection*{Template parameters}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{dataT}} \sphinxhyphen{} type of buffer element
\item[] \sphinxcode{\sphinxupquote{dimensions}}\sphinxhyphen{} dimensionality of buffer
\item[] \sphinxcode{\sphinxupquote{accessmode}} \sphinxhyphen{} type of access
\item[] \sphinxcode{\sphinxupquote{accessTarget}} \sphinxhyphen{} type of memory
\item[] \sphinxcode{\sphinxupquote{isPlaceholder}} \sphinxhyphen{} placeholder
\end{DUlineblock}
\subsubsection*{Member types}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{value\_type}}
&
dataT
\\
\hline
\sphinxcode{\sphinxupquote{reference}}
&
dataT\&
\\
\hline
\sphinxcode{\sphinxupquote{const\_reference}}
&
const dataT\&
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

(constructor)
&
constructs an accessor
\\
\hline
(destructor)
&
destroys the accessor
\\
\hline
is\_placeholder
&\\
\hline
{\hyperref[\detokenize{programming-interface/data/accessor:get-size}]{\sphinxcrossref{get\_size}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/data/accessor:get-count}]{\sphinxcrossref{get\_count}}}
&\\
\hline
get\_range
&\\
\hline
get\_offset
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{get\_size}
\label{\detokenize{programming-interface/data/accessor:get-size}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size\PYGZus{}t} \PYG{n}{get\PYGZus{}size}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}
\end{sphinxVerbatim}

Description


\paragraph{get\_count}
\label{\detokenize{programming-interface/data/accessor:get-count}}

\subsection{Address space classes}
\label{\detokenize{programming-interface/data/address-space:address-space-classes}}\label{\detokenize{programming-interface/data/address-space::doc}}

\subsection{Samplers}
\label{\detokenize{programming-interface/data/sampler:samplers}}\label{\detokenize{programming-interface/data/sampler::doc}}

\section{Expressing parallelism}
\label{\detokenize{programming-interface/index:expressing-parallelism}}

\subsection{Ranges and index space identifiers}
\label{\detokenize{programming-interface/parallelism/range:ranges-and-index-space-identifiers}}\label{\detokenize{programming-interface/parallelism/range::doc}}

\subsection{Command group handler class}
\label{\detokenize{programming-interface/parallelism/command-group:command-group-handler-class}}\label{\detokenize{programming-interface/parallelism/command-group::doc}}

\subsection{Invoking kernels}
\label{\detokenize{programming-interface/parallelism/invoking-kernels:invoking-kernels}}\label{\detokenize{programming-interface/parallelism/invoking-kernels::doc}}

\subsection{Memory operations}
\label{\detokenize{programming-interface/parallelism/memory:memory-operations}}\label{\detokenize{programming-interface/parallelism/memory::doc}}

\subsection{Kernel class}
\label{\detokenize{programming-interface/parallelism/kernel:kernel-class}}\label{\detokenize{programming-interface/parallelism/kernel::doc}}

\subsection{Program class}
\label{\detokenize{programming-interface/parallelism/program:program-class}}\label{\detokenize{programming-interface/parallelism/program::doc}}

\section{Error handling}
\label{\detokenize{programming-interface/index:error-handling}}

\subsection{Exception Class Interface}
\label{\detokenize{programming-interface/error/exception:exception-class-interface}}\label{\detokenize{programming-interface/error/exception::doc}}

\section{Data types}
\label{\detokenize{programming-interface/index:data-types}}

\subsection{Scalar types}
\label{\detokenize{programming-interface/types/scalar:scalar-types}}\label{\detokenize{programming-interface/types/scalar::doc}}

\subsection{Vector types}
\label{\detokenize{programming-interface/types/vector:vector-types}}\label{\detokenize{programming-interface/types/vector::doc}}

\section{Synchronization and atomics}
\label{\detokenize{programming-interface/index:synchronization-and-atomics}}

\subsection{Synchronization types}
\label{\detokenize{programming-interface/synchronization/types:synchronization-types}}\label{\detokenize{programming-interface/synchronization/types::doc}}

\section{Stream class}
\label{\detokenize{programming-interface/index:stream-class}}

\subsection{Stream class interface}
\label{\detokenize{programming-interface/stream/stream:stream-class-interface}}\label{\detokenize{programming-interface/stream/stream::doc}}

\section{Built\sphinxhyphen{}in functions}
\label{\detokenize{programming-interface/index:built-in-functions}}

\subsection{Math functions}
\label{\detokenize{programming-interface/built-in/math:math-functions}}\label{\detokenize{programming-interface/built-in/math::doc}}

\subsection{Integer functions}
\label{\detokenize{programming-interface/built-in/integer:integer-functions}}\label{\detokenize{programming-interface/built-in/integer::doc}}

\subsection{Common functions}
\label{\detokenize{programming-interface/built-in/common:common-functions}}\label{\detokenize{programming-interface/built-in/common::doc}}

\subsection{Geometric functions}
\label{\detokenize{programming-interface/built-in/geometric:geometric-functions}}\label{\detokenize{programming-interface/built-in/geometric::doc}}

\subsection{Relational functions}
\label{\detokenize{programming-interface/built-in/relational:relational-functions}}\label{\detokenize{programming-interface/built-in/relational::doc}}

\subsection{Vector data load and store functions}
\label{\detokenize{programming-interface/built-in/vector:vector-data-load-and-store-functions}}\label{\detokenize{programming-interface/built-in/vector::doc}}

\subsection{Synchronization functions}
\label{\detokenize{programming-interface/built-in/synchronization:synchronization-functions}}\label{\detokenize{programming-interface/built-in/synchronization::doc}}

\subsection{Printf functions}
\label{\detokenize{programming-interface/built-in/printf:printf-functions}}\label{\detokenize{programming-interface/built-in/printf::doc}}

\chapter{Style Guide}
\label{\detokenize{style-guide/index:style-guide}}\label{\detokenize{style-guide/index::doc}}
We try to follow the style of \sphinxhref{https://cppreference.com}{cppreference}. See \sphinxhref{https://en.cppreference.com/w/Help:Manual\_of\_style}{style manual}.


\section{ClassExample}
\label{\detokenize{style-guide/ClassExample:classexample}}\label{\detokenize{style-guide/ClassExample::doc}}\subsubsection*{Parameters}
\subsubsection*{Parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template}\PYG{o}{\PYGZlt{}}
    \PYG{k}{class} \PYG{n+nc}{T1}
    \PYG{k}{class} \PYG{n+nc}{T2}
\PYG{o}{\PYGZgt{}} \PYG{k}{class} \PYG{n+nc}{ClassExample}\PYG{p}{;}
\end{sphinxVerbatim}

This is the description of the class. It is followed by a set of
tables for template parameters and class members. This is followed by
the member functions, one section each.
\subsubsection*{Template parameters}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{T1}} \sphinxhyphen{} description of parameter
\item[] \sphinxcode{\sphinxupquote{T2}} \sphinxhyphen{} description of parameter
\end{DUlineblock}
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{style-guide/ClassExample:constructor}]{\sphinxcrossref{(constructor)}}}
&
constructs a ClassExample
\\
\hline
fun1
&
checks 
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Non\sphinxhyphen{}member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{style-guide/ClassExample:operator}]{\sphinxcrossref{operator+}}}
&
Adds 
\\
\hline
{\hyperref[\detokenize{style-guide/ClassExample:fun3}]{\sphinxcrossref{fun3}}}
&
Queries 
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Example}

Describe the example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}CL/sycl.hpp\PYGZgt{}}

\PYG{n}{namespace} \PYG{n}{sycl} \PYG{o}{=} \PYG{n}{cl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{sycl}\PYG{p}{;}

\PYG{n+nb}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{auto} \PYG{n}{platforms} \PYG{o}{=} \PYG{n}{sycl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{platform}\PYG{p}{:}\PYG{p}{:}\PYG{n}{get\PYGZus{}platforms}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{o}{\PYGZam{}}\PYG{n}{platform} \PYG{p}{:} \PYG{n}{platforms}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Platform: }\PYG{l+s+s2}{\PYGZdq{}}
	      \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{platform}\PYG{o}{.}\PYG{n}{get\PYGZus{}info}\PYG{o}{\PYGZlt{}}\PYG{n}{sycl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{platform}\PYG{p}{:}\PYG{p}{:}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
	      \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}

    \PYG{n}{auto} \PYG{n}{devices} \PYG{o}{=} \PYG{n}{platform}\PYG{o}{.}\PYG{n}{get\PYGZus{}devices}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{o}{\PYGZam{}}\PYG{n}{device} \PYG{p}{:} \PYG{n}{devices} \PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  Device: }\PYG{l+s+s2}{\PYGZdq{}}
		\PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{device}\PYG{o}{.}\PYG{n}{get\PYGZus{}info}\PYG{o}{\PYGZlt{}}\PYG{n}{sycl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device}\PYG{p}{:}\PYG{p}{:}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
		\PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{(constructor)}
\label{\detokenize{style-guide/ClassExample:constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ClassExample}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{sphinxalltt}
ClassExample(int a);            \begin{footnote}[1]\sphinxAtStartFootnote
Describe constructor with one arg
\end{footnote}
\end{sphinxalltt}
\begin{sphinxalltt}
ClassExample(int a, int b);     \begin{footnote}[2]\sphinxAtStartFootnote
Describe constructor with two args
\end{footnote}
\end{sphinxalltt}

Description of the function. The parameters are in a table below. We
have a single table for all the overloads.
\subsubsection*{Parameters}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{a}} \sphinxhyphen{} An argument called a
\item[] \sphinxcode{\sphinxupquote{b}} \sphinxhyphen{} An argument called b
\end{DUlineblock}

Description of the functions. Overloads are grouped together and may
have footnotes for overload\sphinxhyphen{}specific description.
\subsubsection*{Template parameters}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{T}} \sphinxhyphen{} A parameter called T
\end{DUlineblock}
\subsubsection*{Parameters}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{a}} \sphinxhyphen{} A parameter called a
\end{DUlineblock}
\subsubsection*{Example}

A member function can have its own example


\subsection{operator+}
\label{\detokenize{style-guide/ClassExample:operator}}

\subsection{fun3}
\label{\detokenize{style-guide/ClassExample:fun3}}

\chapter{Glossary}
\label{\detokenize{glossary:glossary}}\label{\detokenize{glossary:id1}}\label{\detokenize{glossary::doc}}\begin{description}
\item[{accelerator\index{accelerator@\spxentry{accelerator}|spxpagem}\phantomsection\label{\detokenize{glossary:term-accelerator}}}] \leavevmode
Specialized component containing compute resources that can quickly
execute a subset of operations. Examples include CPU, FPGA, GPU. See
also: {\hyperref[\detokenize{glossary:term-device}]{\sphinxtermref{\DUrole{xref,std,std-term}{device}}}}

\item[{accessor\index{accessor@\spxentry{accessor}|spxpagem}\phantomsection\label{\detokenize{glossary:term-accessor}}}] \leavevmode
Communicates the desired location (host, device) and mode (read,
write) of access.

\item[{application scope\index{application scope@\spxentry{application scope}|spxpagem}\phantomsection\label{\detokenize{glossary:term-application-scope}}}] \leavevmode
Code that executes on the host.

\item[{buffers\index{buffers@\spxentry{buffers}|spxpagem}\phantomsection\label{\detokenize{glossary:term-buffers}}}] \leavevmode
Memory object that communicates the type and number of items of that
type to be communicated to the device for computation.

\item[{command group scope\index{command group scope@\spxentry{command group scope}|spxpagem}\phantomsection\label{\detokenize{glossary:term-command-group-scope}}}] \leavevmode
Code that acts as the interface between the host and device.

\item[{command queue\index{command queue@\spxentry{command queue}|spxpagem}\phantomsection\label{\detokenize{glossary:term-command-queue}}}] \leavevmode
Issues command groups concurrently.

\item[{compute unit\index{compute unit@\spxentry{compute unit}|spxpagem}\phantomsection\label{\detokenize{glossary:term-compute-unit}}}] \leavevmode
A grouping of processing elements into a core that contains shared
elements for use between the processing elements and with faster
access than memory residing on other compute units on the device.

\item[{device\index{device@\spxentry{device}|spxpagem}\phantomsection\label{\detokenize{glossary:term-device}}}] \leavevmode
An accelerator or specialized component containing compute resources
that can quickly execute a subset of operations. A CPU can be
employed as a device, but when it is, it is being employed as an
accelerator. Examples include CPU, FPGA, GPU. See also: {\hyperref[\detokenize{glossary:term-accelerator}]{\sphinxtermref{\DUrole{xref,std,std-term}{accelerator}}}}

\item[{device code\index{device code@\spxentry{device code}|spxpagem}\phantomsection\label{\detokenize{glossary:term-device-code}}}] \leavevmode
Code that executes on the device rather than the host. Device code is
specified via lambda expression, functor, or kernel class.

\item[{fat binary\index{fat binary@\spxentry{fat binary}|spxpagem}\phantomsection\label{\detokenize{glossary:term-fat-binary}}}] \leavevmode
Application binary that contains device code for multiple devices.
The binary includes both the generic code (SPIR\sphinxhyphen{}V representation) and
target specific executable code.

\item[{fat library\index{fat library@\spxentry{fat library}|spxpagem}\phantomsection\label{\detokenize{glossary:term-fat-library}}}] \leavevmode
Archive or library of object code that contains object code for
multiple devices. The fat library includes both the generic object
(SPIR\sphinxhyphen{}V representation) and target specific object code.

\item[{fat object\index{fat object@\spxentry{fat object}|spxpagem}\phantomsection\label{\detokenize{glossary:term-fat-object}}}] \leavevmode
File that contains object code for multiple devices. The fat object
includes both the generic object (SPIR\sphinxhyphen{}V representation) and target
specific object code.

\item[{host\index{host@\spxentry{host}|spxpagem}\phantomsection\label{\detokenize{glossary:term-host}}}] \leavevmode
A CPU\sphinxhyphen{}based system (computer) that executes the primary portion of a
program, specifically the application scope and command group scope.

\item[{host device\index{host device@\spxentry{host device}|spxpagem}\phantomsection\label{\detokenize{glossary:term-host-device}}}] \leavevmode
A SYCL device that is always present and usually executes on the host CPU.

\item[{host code\index{host code@\spxentry{host code}|spxpagem}\phantomsection\label{\detokenize{glossary:term-host-code}}}] \leavevmode
Code that is compiled by the host compiler and executes on the host
rather than the device.

\item[{images\index{images@\spxentry{images}|spxpagem}\phantomsection\label{\detokenize{glossary:term-images}}}] \leavevmode
Formatted opaque memory object that is accessed via built\sphinxhyphen{}in
function. Typically pertains to pictures comprised of pixels stored
in format like RGB.

\item[{kernel scope\index{kernel scope@\spxentry{kernel scope}|spxpagem}\phantomsection\label{\detokenize{glossary:term-kernel-scope}}}] \leavevmode
Code that executes on the device.

\item[{nd\sphinxhyphen{}range\index{nd\sphinxhyphen{}range@\spxentry{nd\sphinxhyphen{}range}|spxpagem}\phantomsection\label{\detokenize{glossary:term-nd-range}}}] \leavevmode
Short for N\sphinxhyphen{}Dimensional Range, a group of kernel instances, or work
item, across one, two, or three dimensions.

\item[{processing element\index{processing element@\spxentry{processing element}|spxpagem}\phantomsection\label{\detokenize{glossary:term-processing-element}}}] \leavevmode
Individual engine for computation that makes up a compute unit.

\item[{single source\index{single source@\spxentry{single source}|spxpagem}\phantomsection\label{\detokenize{glossary:term-single-source}}}] \leavevmode
Code in the same file that can execute on a host and accelerator(s).

\item[{SPIR\sphinxhyphen{}V\index{SPIR\sphinxhyphen{}V@\spxentry{SPIR\sphinxhyphen{}V}|spxpagem}\phantomsection\label{\detokenize{glossary:term-SPIR-V}}}] \leavevmode
Binary intermediate language for representing graphical\sphinxhyphen{}shader stages
and compute kernels.

\item[{sub\sphinxhyphen{}group\index{sub\sphinxhyphen{}group@\spxentry{sub\sphinxhyphen{}group}|spxpagem}\phantomsection\label{\detokenize{glossary:term-sub-group}}}] \leavevmode
Sub\sphinxhyphen{}groups are an Intel extension.

\item[{work\sphinxhyphen{}group\index{work\sphinxhyphen{}group@\spxentry{work\sphinxhyphen{}group}|spxpagem}\phantomsection\label{\detokenize{glossary:term-work-group}}}] \leavevmode
Collection of work\sphinxhyphen{}items that execute on a compute unit.

\item[{work\sphinxhyphen{}item\index{work\sphinxhyphen{}item@\spxentry{work\sphinxhyphen{}item}|spxpagem}\phantomsection\label{\detokenize{glossary:term-work-item}}}] \leavevmode
Basic unit of computation in the oneAPI programming model. It is
associated with a kernel which executes on the processing element.

\end{description}



\renewcommand{\indexname}{Index}
\printindex
\end{document}