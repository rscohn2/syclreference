%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{SYCL Reference}
\date{Apr 26, 2020}
\release{}
\author{Intel}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Language}
\label{\detokenize{language/index:language}}\label{\detokenize{language/index::doc}}
SYCL programs are C++ programs. No extensions are added to the language.

\begin{sphinxadmonition}{note}{\label{\detokenize{language/index:id1}}Todo:}
C++ version mininum
\end{sphinxadmonition}


\section{Keywords}
\label{\detokenize{language/index:keywords}}
SYCL does not add any keywords to the C++ language.


\section{Preprocessor Directives and Macros}
\label{\detokenize{language/index:preprocessor-directives-and-macros}}
Standard C++ preprocessing directives and macros are supported by the
compiler. In addition, the SYCL Specification defines the SYCL specific
preprocessor directives and macros.

The following preprocessor macros are supported by the compiler.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Macro
&\sphinxstyletheadfamily 
Value
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{SYCL\_DUMP\_IMAGES}}
&
\sphinxcode{\sphinxupquote{true}} or \sphinxcode{\sphinxupquote{false}}
&
Instructs the runtime to dump the device image
\\
\hline
\sphinxcode{\sphinxupquote{SYCL\_USE\_KERNEL\_SPV}}
&
\textless{}device binary\textgreater{}
&
Employ device binary to fulfill kernel launch request
\\
\hline
\sphinxcode{\sphinxupquote{SYCL\_PROGRAM\_BUILD\_OPTIONS}}
&
\textless{}options\textgreater{}
&
Used to pass additional options for device program building.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Standard Library Classes Required for the Interface}
\label{\detokenize{language/index:standard-library-classes-required-for-the-interface}}
The SYCL specification documents a facility to enable vendors to provide
custom optimized implementations. Implementations require aliases for
several STL interfaces. These are summarized as follows:

\begin{sphinxadmonition}{note}{\label{\detokenize{language/index:id2}}Todo:}
add STL interfaces
\end{sphinxadmonition}


\chapter{Programming Interface}
\label{\detokenize{programming-interface/index:programming-interface}}\label{\detokenize{programming-interface/index:dpcpp-classes-class-templates-and-defines}}\label{\detokenize{programming-interface/index::doc}}
The Data Parallel C++ (DPC++) programming language and runtime consists
of a set of C++ classes, templates, and libraries used to express a
DPC++program. This chapter provides a summary of the key classes,
templates, and runtime libraries used to program.


\section{Header File}
\label{\detokenize{programming-interface/index:header-file}}

\section{Namespaces}
\label{\detokenize{programming-interface/index:namespaces}}

\section{Class Descriptions}
\label{\detokenize{programming-interface/index:class-descriptions}}
The following sections provide further details on these items. These
sections do not provide the exhaustive details found in the SYCL
Specification. Instead, these sections provide:
\begin{itemize}
\item {} 
A summary that includes a description and the purpose

\item {} 
Comments on the different constructors, if applicable

\item {} 
Member function information, if applicable

\item {} 
Special cases to consider with the DPC++ implementation compared to
the SYCL Specification

\end{itemize}

For further details on SYCL, see the \sphinxhref{https://www.khronos.org/registry/SYCL/specs/sycl-1.2.1.pdf}{SYCL
Specification}.


\subsection{Runtime Classes}
\label{\detokenize{programming-interface/runtime/index:runtime-classes}}\label{\detokenize{programming-interface/runtime/index::doc}}

\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{device\_selector}}}
\label{\detokenize{programming-interface/runtime/device-selector:device-selector}}\label{\detokenize{programming-interface/runtime/device-selector::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{device\PYGZus{}selector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/device-selector:constructor}]{\sphinxcrossref{(constructor)}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device-selector:destructor}]{\sphinxcrossref{(destructor)}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device-selector:select-device}]{\sphinxcrossref{select\_device}}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Non\sphinxhyphen{}member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

operator()
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{(constructor)}}}
\label{\detokenize{programming-interface/runtime/device-selector:constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{device\PYGZus{}selector}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{rhs}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{rhs}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{(destructor)}}}
\label{\detokenize{programming-interface/runtime/device-selector:destructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{device\PYGZus{}selector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{select\_device}}}
\label{\detokenize{programming-interface/runtime/device-selector:select-device}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{device} \PYG{n}{select\PYGZus{}device}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{operator()}}}
\label{\detokenize{programming-interface/runtime/device-selector:operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{virtual} \PYG{n+nb}{int} \PYG{n}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{device}\PYG{p}{)} \PYG{n}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{platform}}}
\label{\detokenize{programming-interface/runtime/platform:platform}}\label{\detokenize{programming-interface/runtime/platform::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{platform}\PYG{p}{;}
\end{sphinxVerbatim}

Abstraction for SYCL platform.
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/platform:constructor}]{\sphinxcrossref{(constructor)}}}
&
constructs a platform
\\
\hline
(destructor)
&
destroys a platform
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/platform:get}]{\sphinxcrossref{get}}}
&
returns OpenCL platform ID
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/platform:get-devices}]{\sphinxcrossref{get\_devices}}}
&
returns devices bound to the platform
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/platform:get-info}]{\sphinxcrossref{get\_info}}}
&
queries properties of the platform
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/platform:has-extension}]{\sphinxcrossref{has\_extension}}}
&
checks if platform has an extension
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/platform:is-host}]{\sphinxcrossref{is\_host}}}
&
checks if platform has a SYCL host device
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Non\sphinxhyphen{}member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/platform:get-platforms}]{\sphinxcrossref{get\_platforms}}}
&
returns available platforms
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\phantomsection\label{\detokenize{programming-interface/runtime/platform:platform-example}}\subsubsection*{Example}

Demonstrates several methods for \sphinxcode{\sphinxupquote{platform}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}include \PYGZlt{}CL/sycl.hpp\PYGZgt{}}

\PYG{n}{namespace} \PYG{n}{sycl} \PYG{o}{=} \PYG{n}{cl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{sycl}\PYG{p}{;}

\PYG{n+nb}{int} \PYG{n}{main}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{auto} \PYG{n}{platforms} \PYG{o}{=} \PYG{n}{sycl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{platform}\PYG{p}{:}\PYG{p}{:}\PYG{n}{get\PYGZus{}platforms}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{o}{\PYGZam{}}\PYG{n}{platform} \PYG{p}{:} \PYG{n}{platforms}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Platform: }\PYG{l+s+s2}{\PYGZdq{}}
	      \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{platform}\PYG{o}{.}\PYG{n}{get\PYGZus{}info}\PYG{o}{\PYGZlt{}}\PYG{n}{sycl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{platform}\PYG{p}{:}\PYG{p}{:}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
	      \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}

    \PYG{n}{auto} \PYG{n}{devices} \PYG{o}{=} \PYG{n}{platform}\PYG{o}{.}\PYG{n}{get\PYGZus{}devices}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{o}{\PYGZam{}}\PYG{n}{device} \PYG{p}{:} \PYG{n}{devices} \PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  Device: }\PYG{l+s+s2}{\PYGZdq{}}
		\PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{device}\PYG{o}{.}\PYG{n}{get\PYGZus{}info}\PYG{o}{\PYGZlt{}}\PYG{n}{sycl}\PYG{p}{:}\PYG{p}{:}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device}\PYG{p}{:}\PYG{p}{:}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
		\PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Platform}\PYG{p}{:} \PYG{n}{Intel}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{n}{FPGA} \PYG{n}{Emulation} \PYG{n}{Platform} \PYG{k}{for} \PYG{n}{OpenCL}\PYG{p}{(}\PYG{n}{TM}\PYG{p}{)}
  \PYG{n}{Device}\PYG{p}{:} \PYG{n}{Intel}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{n}{FPGA} \PYG{n}{Emulation} \PYG{n}{Device}
\PYG{n}{Platform}\PYG{p}{:} \PYG{n}{Intel}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{n}{OpenCL}
  \PYG{n}{Device}\PYG{p}{:} \PYG{n}{Intel}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{n}{Core}\PYG{p}{(}\PYG{n}{TM}\PYG{p}{)} \PYG{n}{i5}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7300}\PYG{n}{U} \PYG{n}{CPU} \PYG{o}{@} \PYG{l+m+mf}{2.60}\PYG{n}{GHz}
\PYG{n}{Platform}\PYG{p}{:} \PYG{n}{Intel}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{n}{CPU} \PYG{n}{Runtime} \PYG{k}{for} \PYG{n}{OpenCL}\PYG{p}{(}\PYG{n}{TM}\PYG{p}{)} \PYG{n}{Applications}
  \PYG{n}{Device}\PYG{p}{:} \PYG{n}{Intel}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{n}{Core}\PYG{p}{(}\PYG{n}{TM}\PYG{p}{)} \PYG{n}{i5}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7300}\PYG{n}{U} \PYG{n}{CPU} \PYG{o}{@} \PYG{l+m+mf}{2.60}\PYG{n}{GHz}
\PYG{n}{Platform}\PYG{p}{:} \PYG{n}{SYCL} \PYG{n}{host} \PYG{n}{platform}
  \PYG{n}{Device}\PYG{p}{:} \PYG{n}{SYCL} \PYG{n}{host} \PYG{n}{device}
\end{sphinxVerbatim}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{(constructor)}}}
\label{\detokenize{programming-interface/runtime/platform:constructor}}\begin{sphinxalltt}
platform();
explicit platform(cl\_platform\_id platformID); \begin{footnote}[1]\sphinxAtStartFootnote
Constructs a SYCL platform that retains an OpenCL id
\end{footnote}
explicit platform(const device\_selector \&deviceSelector); \begin{footnote}[2]\sphinxAtStartFootnote
Selects a platform that contains the desired device
\end{footnote}
\end{sphinxalltt}

Constructs a platform handle.
\subsubsection*{Arguments}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{platformID}}
&
OpenCL platform ID
\\
\hline
\sphinxcode{\sphinxupquote{deviceSelector}}
&
Platform must contain the selected device
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get}}}
\label{\detokenize{programming-interface/runtime/platform:get}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cl\PYGZus{}platform\PYGZus{}id} \PYG{n}{get}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Returns OpenCL platform id used in the constructor.


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_devices}}}
\label{\detokenize{programming-interface/runtime/platform:get-devices}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{device}\PYG{o}{\PYGZgt{}} \PYG{n}{get\PYGZus{}devices}\PYG{p}{(}
   \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device\PYGZus{}type} \PYG{o}{=} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device\PYGZus{}type}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{all}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Returns vector of devices of the requested type
\subsubsection*{Arguments}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{device\_type}}
&
limits type of device returned
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Return value}

\sphinxcode{\sphinxupquote{vector}} containing devices of the specified type bound to the
platform.
\subsubsection*{Example}

See {\hyperref[\detokenize{programming-interface/runtime/platform:platform-example}]{\sphinxcrossref{\DUrole{std,std-ref}{Example}}}}.


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_info}}}
\label{\detokenize{programming-interface/runtime/platform:get-info}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template}\PYG{o}{\PYGZlt{}} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{platform} \PYG{n}{param} \PYG{o}{\PYGZgt{}}
\PYG{n}{typename} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{param\PYGZus{}traits}\PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{platform}\PYG{p}{,} \PYG{n}{param}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{return\PYGZus{}type} \PYG{n}{get\PYGZus{}info}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Returns information about the platform, as specified by \sphinxcode{\sphinxupquote{param}}.
\subsubsection*{Return value}

Requested information
\subsubsection*{Example}

See {\hyperref[\detokenize{programming-interface/runtime/platform:platform-example}]{\sphinxcrossref{\DUrole{std,std-ref}{Example}}}}.


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{has\_extension}}}
\label{\detokenize{programming-interface/runtime/platform:has-extension}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{has\PYGZus{}extension}\PYG{p}{(}\PYG{n}{const} \PYG{n}{string\PYGZus{}class} \PYG{o}{\PYGZam{}}\PYG{n}{extension}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Checks if the platform has the requested extension.
\subsubsection*{Arguments}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{extension}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Return value}

\sphinxcode{\sphinxupquote{true}} if the platform has \sphinxcode{\sphinxupquote{extension}}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{is\_host}}}
\label{\detokenize{programming-interface/runtime/platform:is-host}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}host}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}

Checks if the platform contains a SYCL {\hyperref[\detokenize{glossary:term-host-device}]{\sphinxtermref{\DUrole{xref,std,std-term}{host device}}}}
\subsubsection*{Return value}

\sphinxcode{\sphinxupquote{true}} if the platform contains a host device


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_platforms}}}
\label{\detokenize{programming-interface/runtime/platform:get-platforms}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{static} \PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{platform}\PYG{o}{\PYGZgt{}} \PYG{n}{get\PYGZus{}platforms}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Returns vector of platforms
\subsubsection*{Return value}

vector\_class containing SYCL platforms bound to the system
\subsubsection*{Example}

See {\hyperref[\detokenize{programming-interface/runtime/platform:platform-example}]{\sphinxcrossref{\DUrole{std,std-ref}{Example}}}}.


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{context}}}
\label{\detokenize{programming-interface/runtime/context:context}}\label{\detokenize{programming-interface/runtime/context::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{context}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/context:constructor}]{\sphinxcrossref{(constructor)}}}
&
constructs a context
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/context:get}]{\sphinxcrossref{get}}}
&
returns OpenCL conext ID
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/context:is-host}]{\sphinxcrossref{is\_host}}}
&
checks if contains a SYCL host device
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/context:get-platform}]{\sphinxcrossref{get\_platform}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/context:get-devices}]{\sphinxcrossref{get\_devices}}}
&
returns devices bound to the context
\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/context:get-info}]{\sphinxcrossref{get\_info}}}
&
queries properties
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{(constructor)}}}
\label{\detokenize{programming-interface/runtime/context:constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{p}{(}\PYG{n}{async\PYGZus{}handler} \PYG{n}{asyncHandler}\PYG{p}{,}
        \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{dev}\PYG{p}{,} \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{dev}\PYG{p}{,} \PYG{n}{async\PYGZus{}handler} \PYG{n}{asyncHandler}\PYG{p}{,}
        \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{platform} \PYG{o}{\PYGZam{}}\PYG{n}{plt}\PYG{p}{,} \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{platform} \PYG{o}{\PYGZam{}}\PYG{n}{plt}\PYG{p}{,} \PYG{n}{async\PYGZus{}handler} \PYG{n}{asyncHandler}\PYG{p}{,}
        \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{device}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{deviceList}\PYG{p}{,}
        \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{p}{(}\PYG{n}{const} \PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{device}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{deviceList}\PYG{p}{,}
        \PYG{n}{async\PYGZus{}handler} \PYG{n}{asyncHandler}\PYG{p}{,} \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{p}{(}\PYG{n}{cl\PYGZus{}context} \PYG{n}{clContext}\PYG{p}{,} \PYG{n}{async\PYGZus{}handler} \PYG{n}{asyncHandler} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Arguments}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{propList}}
&\\
\hline
\sphinxcode{\sphinxupquote{asyncHandler}}
&\\
\hline
\sphinxcode{\sphinxupquote{dev}}
&\\
\hline
\sphinxcode{\sphinxupquote{plt}}
&\\
\hline
\sphinxcode{\sphinxupquote{deviceList}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get}}}
\label{\detokenize{programming-interface/runtime/context:get}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cl\PYGZus{}context} \PYG{n}{get}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{is\_host}}}
\label{\detokenize{programming-interface/runtime/context:is-host}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}host}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_platform}}}
\label{\detokenize{programming-interface/runtime/context:get-platform}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{platform} \PYG{n}{get\PYGZus{}platform}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_devices}}}
\label{\detokenize{programming-interface/runtime/context:get-devices}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{device}\PYG{o}{\PYGZgt{}} \PYG{n}{get\PYGZus{}devices}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_info}}}
\label{\detokenize{programming-interface/runtime/context:get-info}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{context} \PYG{n}{param}\PYG{o}{\PYGZgt{}}
\PYG{n}{typename} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{param\PYGZus{}traits}\PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{context}\PYG{p}{,} \PYG{n}{param}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{return\PYGZus{}type} \PYG{n}{get\PYGZus{}info}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{device}}}
\label{\detokenize{programming-interface/runtime/device:device}}\label{\detokenize{programming-interface/runtime/device::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{device}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/device:constructor}]{\sphinxcrossref{(constructor)}}}
&\\
\hline
(destructor)
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:get}]{\sphinxcrossref{get}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:is-host}]{\sphinxcrossref{is\_host}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:is-cpu}]{\sphinxcrossref{is\_cpu}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:is-gpu}]{\sphinxcrossref{is\_gpu}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:is-accelerator}]{\sphinxcrossref{is\_accelerator}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:get-platform}]{\sphinxcrossref{get\_platform}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:get-info}]{\sphinxcrossref{get\_info}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:has-extension}]{\sphinxcrossref{has\_extension}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/device:create-sub-devices}]{\sphinxcrossref{create\_sub\_devices}}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Non\sphinxhyphen{}member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/device:get-devices}]{\sphinxcrossref{get\_devices}}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{(constructor)}}}
\label{\detokenize{programming-interface/runtime/device:constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{device}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{explicit} \PYG{n}{device}\PYG{p}{(}\PYG{n}{cl\PYGZus{}device\PYGZus{}id} \PYG{n}{deviceId}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{explicit} \PYG{n}{device}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{deviceSelector}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Arguments}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{deviceID}}
&\\
\hline
\sphinxcode{\sphinxupquote{deviceSelector}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get}}}
\label{\detokenize{programming-interface/runtime/device:get}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cl\PYGZus{}device\PYGZus{}id} \PYG{n}{get}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{is\_host}}}
\label{\detokenize{programming-interface/runtime/device:is-host}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}host}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{is\_cpu}}}
\label{\detokenize{programming-interface/runtime/device:is-cpu}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}cpu}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{is\_gpu}}}
\label{\detokenize{programming-interface/runtime/device:is-gpu}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}gpu}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{is\_accelerator}}}
\label{\detokenize{programming-interface/runtime/device:is-accelerator}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}accelerator}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_platform}}}
\label{\detokenize{programming-interface/runtime/device:get-platform}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{platform} \PYG{n}{get\PYGZus{}platform}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_info}}}
\label{\detokenize{programming-interface/runtime/device:get-info}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device} \PYG{n}{param}\PYG{o}{\PYGZgt{}}
\PYG{n}{typename} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{param\PYGZus{}traits}\PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device}\PYG{p}{,} \PYG{n}{param}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{return\PYGZus{}type}
\PYG{n}{get\PYGZus{}info}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}
\subsubsection*{Example}

See {\hyperref[\detokenize{programming-interface/runtime/platform:platform-example}]{\sphinxcrossref{\DUrole{std,std-ref}{Example}}}}.


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{has\_extension}}}
\label{\detokenize{programming-interface/runtime/device:has-extension}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{has\PYGZus{}extension}\PYG{p}{(}\PYG{n}{const} \PYG{n}{string\PYGZus{}class} \PYG{o}{\PYGZam{}}\PYG{n}{extension}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Arguments}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{extension}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{create\_sub\_devices}}}
\label{\detokenize{programming-interface/runtime/device:create-sub-devices}}\begin{sphinxalltt}
template \textless{}\sphinxurl{info::partition\_property} prop\textgreater{}
vector\_class\textless{}device\textgreater{} create\_sub\_devices(size\_t nbSubDev) const; \begin{footnote}[4]\sphinxAtStartFootnote
Available only when prop == \sphinxurl{info::partition\_property::partition\_equally}
\end{footnote}

template \textless{}\sphinxurl{info::partition\_property} prop\textgreater{}
vector\_class\textless{}device\textgreater{} create\_sub\_devices(const vector\_class\textless{}size\_t\textgreater{} \&counts) const; \begin{footnote}[5]\sphinxAtStartFootnote
Available only when prop == \sphinxurl{info::partition\_property::partition\_by\_counts}
\end{footnote}

template \textless{}\sphinxurl{info::partition\_property} prop\textgreater{}
vector\_class\textless{}device\textgreater{} create\_sub\_devices(\sphinxurl{info::affinity\_domain} affinityDomain) const; \begin{footnote}[6]\sphinxAtStartFootnote
Available only when prop == \sphinxurl{info::partition\_property::partition\_by\_affinity\_domain}
\end{footnote}
\end{sphinxalltt}
\subsubsection*{Arguments}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

nbSubDev
&\\
\hline
counts
&\\
\hline
affinityDomain
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_devices}}}
\label{\detokenize{programming-interface/runtime/device:get-devices}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{static} \PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{device}\PYG{o}{\PYGZgt{}} \PYG{n}{get\PYGZus{}devices}\PYG{p}{(}
    \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device\PYGZus{}type} \PYG{n}{deviceType} \PYG{o}{=} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{device\PYGZus{}type}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{all}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{queue}}}
\label{\detokenize{programming-interface/runtime/queue:queue}}\label{\detokenize{programming-interface/runtime/queue::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{queue}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/queue:constructor}]{\sphinxcrossref{(constructor)}}}
&\\
\hline
(destructor)
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:get}]{\sphinxcrossref{get}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:get-context}]{\sphinxcrossref{get\_context}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:get-device}]{\sphinxcrossref{get\_device}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:get-info}]{\sphinxcrossref{get\_info}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:is-host}]{\sphinxcrossref{is\_host}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:submit}]{\sphinxcrossref{submit}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:wait}]{\sphinxcrossref{wait}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:wait-and-throw}]{\sphinxcrossref{wait\_and\_throw}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/queue:throw-asynchronous}]{\sphinxcrossref{throw\_asynchronous}}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{(constructor)}}}
\label{\detokenize{programming-interface/runtime/queue:constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{async\PYGZus{}handler} \PYG{o}{\PYGZam{}}\PYG{n}{asyncHandler}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{deviceSelector}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{deviceSelector}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{async\PYGZus{}handler} \PYG{o}{\PYGZam{}}\PYG{n}{asyncHandler}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{syclDevice}\PYG{p}{,} \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{syclDevice}\PYG{p}{,} \PYG{n}{const} \PYG{n}{async\PYGZus{}handler} \PYG{o}{\PYGZam{}}\PYG{n}{asyncHandler}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{context} \PYG{o}{\PYGZam{}}\PYG{n}{syclContext}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{deviceSelector}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{context} \PYG{o}{\PYGZam{}}\PYG{n}{syclContext}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{device\PYGZus{}selector} \PYG{o}{\PYGZam{}}\PYG{n}{deviceSelector}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{async\PYGZus{}handler} \PYG{o}{\PYGZam{}}\PYG{n}{asyncHandler}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{context} \PYG{o}{\PYGZam{}}\PYG{n}{syclContext}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{syclDevice}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{const} \PYG{n}{context} \PYG{o}{\PYGZam{}}\PYG{n}{syclContext}\PYG{p}{,} \PYG{n}{const} \PYG{n}{device} \PYG{o}{\PYGZam{}}\PYG{n}{syclDevice}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{async\PYGZus{}handler} \PYG{o}{\PYGZam{}}\PYG{n}{asyncHandler}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{property\PYGZus{}list} \PYG{o}{\PYGZam{}}\PYG{n}{propList} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{explicit} \PYG{n}{queue}\PYG{p}{(}\PYG{n}{cl\PYGZus{}command\PYGZus{}queue} \PYG{n}{clQueue}\PYG{p}{,} \PYG{n}{const} \PYG{n}{context}\PYG{o}{\PYGZam{}} \PYG{n}{syclContext}\PYG{p}{,}
               \PYG{n}{const} \PYG{n}{async\PYGZus{}handler} \PYG{o}{\PYGZam{}}\PYG{n}{asyncHandler} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get}}}
\label{\detokenize{programming-interface/runtime/queue:get}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cl\PYGZus{}command\PYGZus{}queue} \PYG{n}{get}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_context}}}
\label{\detokenize{programming-interface/runtime/queue:get-context}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{context} \PYG{n}{get\PYGZus{}context}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_device}}}
\label{\detokenize{programming-interface/runtime/queue:get-device}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{device} \PYG{n}{get\PYGZus{}device}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{is\_host}}}
\label{\detokenize{programming-interface/runtime/queue:is-host}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}host}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_info}}}
\label{\detokenize{programming-interface/runtime/queue:get-info}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{queue} \PYG{n}{param}\PYG{o}{\PYGZgt{}}
\PYG{n}{typename} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{param\PYGZus{}traits}\PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{queue}\PYG{p}{,} \PYG{n}{param}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{return\PYGZus{}type} \PYG{n}{get\PYGZus{}info}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{submit}}}
\label{\detokenize{programming-interface/runtime/queue:submit}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{event} \PYG{n}{submit}\PYG{p}{(}\PYG{n}{T} \PYG{n}{cgf}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{event} \PYG{n}{submit}\PYG{p}{(}\PYG{n}{T} \PYG{n}{cgf}\PYG{p}{,} \PYG{n}{const} \PYG{n}{queue} \PYG{o}{\PYGZam{}}\PYG{n}{secondaryQueue}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Arguments}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{cgf}}
&\\
\hline
\sphinxcode{\sphinxupquote{secondaryQueue}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{wait}}}
\label{\detokenize{programming-interface/runtime/queue:wait}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{wait}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{wait\_and\_throw}}}
\label{\detokenize{programming-interface/runtime/queue:wait-and-throw}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{wait\PYGZus{}and\PYGZus{}throw}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{throw\_asynchronous}}}
\label{\detokenize{programming-interface/runtime/queue:throw-asynchronous}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{throw\PYGZus{}asynchronous}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{event}}}
\label{\detokenize{programming-interface/runtime/event:event}}\label{\detokenize{programming-interface/runtime/event::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{event}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{\hyperref[\detokenize{programming-interface/runtime/event:constructor}]{\sphinxcrossref{(constructor)}}}
&\\
\hline
(destructor)
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:cl-event-get}]{\sphinxcrossref{cl\_event\_get}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:is-host}]{\sphinxcrossref{is\_host}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:get-wait-list}]{\sphinxcrossref{get\_wait\_list}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:wait}]{\sphinxcrossref{wait}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:wait-and-throw}]{\sphinxcrossref{wait\_and\_throw}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:get-info}]{\sphinxcrossref{get\_info}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/runtime/event:get-profiling-info}]{\sphinxcrossref{get\_profiling\_info}}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{(constructor)}}}
\label{\detokenize{programming-interface/runtime/event:constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{event}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{event}\PYG{p}{(}\PYG{n}{cl\PYGZus{}event} \PYG{n}{clEvent}\PYG{p}{,} \PYG{n}{const} \PYG{n}{context}\PYG{o}{\PYGZam{}} \PYG{n}{syclContext}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{cl\_event\_get}}}
\label{\detokenize{programming-interface/runtime/event:cl-event-get}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cl\PYGZus{}event} \PYG{n}{get}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{is\_host}}}
\label{\detokenize{programming-interface/runtime/event:is-host}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bool} \PYG{n}{is\PYGZus{}host}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_wait\_list}}}
\label{\detokenize{programming-interface/runtime/event:get-wait-list}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{event}\PYG{o}{\PYGZgt{}} \PYG{n}{get\PYGZus{}wait\PYGZus{}list}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{wait}}}
\label{\detokenize{programming-interface/runtime/event:wait}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{wait}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{static} \PYG{n}{void} \PYG{n}{wait}\PYG{p}{(}\PYG{n}{const} \PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{event}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{eventList}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{wait\_and\_throw}}}
\label{\detokenize{programming-interface/runtime/event:wait-and-throw}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{wait\PYGZus{}and\PYGZus{}throw}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{static} \PYG{n}{void} \PYG{n}{wait\PYGZus{}and\PYGZus{}throw}\PYG{p}{(}\PYG{n}{const} \PYG{n}{vector\PYGZus{}class}\PYG{o}{\PYGZlt{}}\PYG{n}{event}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{eventList}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_info}}}
\label{\detokenize{programming-interface/runtime/event:get-info}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{event} \PYG{n}{param}\PYG{o}{\PYGZgt{}}
\PYG{n}{typename} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{param\PYGZus{}traits}\PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{event}\PYG{p}{,} \PYG{n}{param}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{return\PYGZus{}type} \PYG{n}{get\PYGZus{}info}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_profiling\_info}}}
\label{\detokenize{programming-interface/runtime/event:get-profiling-info}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{event\PYGZus{}profiling} \PYG{n}{param}\PYG{o}{\PYGZgt{}}
\PYG{n}{typename} \PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{param\PYGZus{}traits}\PYG{o}{\PYGZlt{}}\PYG{n}{info}\PYG{p}{:}\PYG{p}{:}\PYG{n}{event\PYGZus{}profiling}\PYG{p}{,} \PYG{n}{param}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{return\PYGZus{}type} \PYG{n}{get\PYGZus{}profiling\PYGZus{}info}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\subsubsection*{Return value}


\subsection{Data Access}
\label{\detokenize{programming-interface/data/index:data-access}}\label{\detokenize{programming-interface/data/index::doc}}

\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{accessor}}}
\label{\detokenize{programming-interface/data/accessor:accessor}}\label{\detokenize{programming-interface/data/accessor::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{template}\PYG{o}{\PYGZlt{}}
    \PYG{n}{typename} \PYG{n}{dataT}\PYG{p}{,}
    \PYG{n+nb}{int} \PYG{n}{dimensions}\PYG{p}{,}
    \PYG{n}{access}\PYG{p}{:}\PYG{p}{:}\PYG{n}{mode} \PYG{n}{accessmode}\PYG{p}{,}
    \PYG{n}{access}\PYG{p}{:}\PYG{p}{:}\PYG{n}{target} \PYG{n}{accessTarget} \PYG{o}{=} \PYG{n}{access}\PYG{p}{:}\PYG{p}{:}\PYG{n}{target}\PYG{p}{:}\PYG{p}{:}\PYG{n}{global\PYGZus{}buffer}\PYG{p}{,}
    \PYG{n}{access}\PYG{p}{:}\PYG{p}{:}\PYG{n}{placeholder} \PYG{n}{isPlaceholder} \PYG{o}{=} \PYG{n}{access}\PYG{p}{:}\PYG{p}{:}\PYG{n}{placeholder}\PYG{p}{:}\PYG{p}{:}\PYG{n}{false\PYGZus{}t}
\PYG{o}{\PYGZgt{}} \PYG{n}{accessor}\PYG{p}{;}
\end{sphinxVerbatim}

A DPC++ \sphinxcode{\sphinxupquote{accessor}} encapsulates reading and writing memory objects
which can be buffers, images, or device local memory. Creating an
accessor requires a method to reference the desired access target.
Construction also requires the type of the memory object, the
dimensionality of the memory object, the access mode, and a placeholder
argument.
\subsubsection*{Template parameters}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{dataT}}
&
type of buffer element
\\
\hline
\sphinxcode{\sphinxupquote{dimensions}}
&
dimensionality of buffer
\\
\hline
\sphinxcode{\sphinxupquote{accessmode}}
&
type of access
\\
\hline
\sphinxcode{\sphinxupquote{accessTarget}}
&
type of memory
\\
\hline
\sphinxcode{\sphinxupquote{isPlaceholder}}
&
placeholder
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Member types}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{value\_type}}
&
dataT
\\
\hline
\sphinxcode{\sphinxupquote{reference}}
&
dataT\&
\\
\hline
\sphinxcode{\sphinxupquote{const\_reference}}
&
const dataT\&
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Member functions}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

(constructor)
&
constructs an accessor
\\
\hline
(destructor)
&
destroys the accessor
\\
\hline
is\_placeholder
&\\
\hline
{\hyperref[\detokenize{programming-interface/data/accessor:get-size}]{\sphinxcrossref{get\_size}}}
&\\
\hline
{\hyperref[\detokenize{programming-interface/data/accessor:get-count}]{\sphinxcrossref{get\_count}}}
&\\
\hline
get\_range
&\\
\hline
get\_offset
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_size}}}
\label{\detokenize{programming-interface/data/accessor:get-size}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size\PYGZus{}t} \PYG{n}{get\PYGZus{}size}\PYG{p}{(}\PYG{p}{)} \PYG{n}{const}
\end{sphinxVerbatim}

Description


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{get\_count}}}
\label{\detokenize{programming-interface/data/accessor:get-count}}\begin{sphinxalltt}
size\_t get\_size() const \begin{footnote}[1]\sphinxAtStartFootnote
No arguments
\end{footnote}
size\_t get\_size(int b) const \begin{footnote}[2]\sphinxAtStartFootnote
single argument
\end{footnote}
size\_t get\_size(int c, int d) const \begin{footnote}[3]\sphinxAtStartFootnote
2 arguments
\end{footnote}
\end{sphinxalltt}

Description


\chapter{Glossary}
\label{\detokenize{glossary:glossary}}\label{\detokenize{glossary:id1}}\label{\detokenize{glossary::doc}}\begin{description}
\item[{accelerator\index{accelerator@\spxentry{accelerator}|spxpagem}\phantomsection\label{\detokenize{glossary:term-accelerator}}}] \leavevmode
Specialized component containing compute resources that can quickly
execute a subset of operations. Examples include CPU, FPGA, GPU. See
also: {\hyperref[\detokenize{glossary:term-device}]{\sphinxtermref{\DUrole{xref,std,std-term}{device}}}}

\item[{accessor\index{accessor@\spxentry{accessor}|spxpagem}\phantomsection\label{\detokenize{glossary:term-accessor}}}] \leavevmode
Communicates the desired location (host, device) and mode (read,
write) of access.

\item[{application scope\index{application scope@\spxentry{application scope}|spxpagem}\phantomsection\label{\detokenize{glossary:term-application-scope}}}] \leavevmode
Code that executes on the host.

\item[{buffers\index{buffers@\spxentry{buffers}|spxpagem}\phantomsection\label{\detokenize{glossary:term-buffers}}}] \leavevmode
Memory object that communicates the type and number of items of that
type to be communicated to the device for computation.

\item[{command group scope\index{command group scope@\spxentry{command group scope}|spxpagem}\phantomsection\label{\detokenize{glossary:term-command-group-scope}}}] \leavevmode
Code that acts as the interface between the host and device.

\item[{command queue\index{command queue@\spxentry{command queue}|spxpagem}\phantomsection\label{\detokenize{glossary:term-command-queue}}}] \leavevmode
Issues command groups concurrently.

\item[{compute unit\index{compute unit@\spxentry{compute unit}|spxpagem}\phantomsection\label{\detokenize{glossary:term-compute-unit}}}] \leavevmode
A grouping of processing elements into a ‘core’ that contains shared
elements for use between the processing elements and with faster
access than memory residing on other compute units on the device.

\item[{device\index{device@\spxentry{device}|spxpagem}\phantomsection\label{\detokenize{glossary:term-device}}}] \leavevmode
An accelerator or specialized component containing compute resources
that can quickly execute a subset of operations. A CPU can be
employed as a device, but when it is, it is being employed as an
accelerator. Examples include CPU, FPGA, GPU. See also: {\hyperref[\detokenize{glossary:term-accelerator}]{\sphinxtermref{\DUrole{xref,std,std-term}{accelerator}}}}

\item[{device code\index{device code@\spxentry{device code}|spxpagem}\phantomsection\label{\detokenize{glossary:term-device-code}}}] \leavevmode
Code that executes on the device rather than the host. Device code is
specified via lambda expression, functor, or kernel class.

\item[{fat binary\index{fat binary@\spxentry{fat binary}|spxpagem}\phantomsection\label{\detokenize{glossary:term-fat-binary}}}] \leavevmode
Application binary that contains device code for multiple devices.
The binary includes both the generic code (SPIR\sphinxhyphen{}V representation) and
target specific executable code.

\item[{fat library\index{fat library@\spxentry{fat library}|spxpagem}\phantomsection\label{\detokenize{glossary:term-fat-library}}}] \leavevmode
Archive or library of object code that contains object code for
multiple devices. The fat library includes both the generic object
(SPIR\sphinxhyphen{}V representation) and target specific object code.

\item[{fat object\index{fat object@\spxentry{fat object}|spxpagem}\phantomsection\label{\detokenize{glossary:term-fat-object}}}] \leavevmode
File that contains object code for multiple devices. The fat object
includes both the generic object (SPIR\sphinxhyphen{}V representation) and target
specific object code.

\item[{host\index{host@\spxentry{host}|spxpagem}\phantomsection\label{\detokenize{glossary:term-host}}}] \leavevmode
A CPU\sphinxhyphen{}based system (computer) that executes the primary portion of a
program, specifically the application scope and command group scope.

\item[{host device\index{host device@\spxentry{host device}|spxpagem}\phantomsection\label{\detokenize{glossary:term-host-device}}}] \leavevmode
A SYCL device that is always present and usually executes on the host CPU.

\item[{host code\index{host code@\spxentry{host code}|spxpagem}\phantomsection\label{\detokenize{glossary:term-host-code}}}] \leavevmode
Code that is compiled by the host compiler and executes on the host
rather than the device.

\item[{images\index{images@\spxentry{images}|spxpagem}\phantomsection\label{\detokenize{glossary:term-images}}}] \leavevmode
Formatted opaque memory object that is accessed via built\sphinxhyphen{}in
function. Typically pertains to pictures comprised of pixels stored
in format like RGB.

\item[{kernel scope\index{kernel scope@\spxentry{kernel scope}|spxpagem}\phantomsection\label{\detokenize{glossary:term-kernel-scope}}}] \leavevmode
Code that executes on the device.

\item[{nd\sphinxhyphen{}range\index{nd\sphinxhyphen{}range@\spxentry{nd\sphinxhyphen{}range}|spxpagem}\phantomsection\label{\detokenize{glossary:term-nd-range}}}] \leavevmode
Short for N\sphinxhyphen{}Dimensional Range, a group of kernel instances, or work
item, across one, two, or three dimensions.

\item[{processing element\index{processing element@\spxentry{processing element}|spxpagem}\phantomsection\label{\detokenize{glossary:term-processing-element}}}] \leavevmode
Individual engine for computation that makes up a compute unit.

\item[{single source\index{single source@\spxentry{single source}|spxpagem}\phantomsection\label{\detokenize{glossary:term-single-source}}}] \leavevmode
Code in the same file that can execute on a host and accelerator(s).

\item[{SPIR\sphinxhyphen{}V\index{SPIR\sphinxhyphen{}V@\spxentry{SPIR\sphinxhyphen{}V}|spxpagem}\phantomsection\label{\detokenize{glossary:term-SPIR-V}}}] \leavevmode
Binary intermediate language for representing graphical\sphinxhyphen{}shader stages
and compute kernels.

\item[{sub\sphinxhyphen{}group\index{sub\sphinxhyphen{}group@\spxentry{sub\sphinxhyphen{}group}|spxpagem}\phantomsection\label{\detokenize{glossary:term-sub-group}}}] \leavevmode
Sub\sphinxhyphen{}groups are an Intel extension.

\item[{work\sphinxhyphen{}group\index{work\sphinxhyphen{}group@\spxentry{work\sphinxhyphen{}group}|spxpagem}\phantomsection\label{\detokenize{glossary:term-work-group}}}] \leavevmode
Collection of work\sphinxhyphen{}items that execute on a compute unit.

\item[{work\sphinxhyphen{}item\index{work\sphinxhyphen{}item@\spxentry{work\sphinxhyphen{}item}|spxpagem}\phantomsection\label{\detokenize{glossary:term-work-item}}}] \leavevmode
Basic unit of computation in the oneAPI programming model. It is
associated with a kernel which executes on the processing element.

\end{description}



\renewcommand{\indexname}{Index}
\printindex
\end{document}